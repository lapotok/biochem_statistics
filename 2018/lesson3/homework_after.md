# Задания

Для работы с пайплайнами и графиками загрузите следующие библиотеки

 ```r
library(tidyverse)
library(ggpubr)
library(magrittr)
library(readxl)
library(car)
```

## Читаем файл и исправляем ошибки

Учимся исправлять ошибки, которые мы уже научились находить

* неправильный десятичный разделитель
* неправильно определенный тип колонки Weight (текст, вместо чисел)
* пропущенные данные, абы как названные (надо составить указания для `R` в формате регулярных выражений, что заменять на NA)
* русскоязычные названия переменных и названия с пробелами, что может вызывать неудобство в работе, например необходимость их закавычивать при обращении к ним (```bad$`Num ticks` ```)
* неправильно определенный тип колонки Weight (текст, вместо чисел)
* в колонке Пол буквы разного регистра обозначают одно и то же

```r
# так можно скачивать файлы из интернета во временный файл, чтобы потом открывать
tmp = tempfile() # генерируем название временного файла
"https://github.com/lapotok/biochem_statistics/blob/master/2018/lesson1/bad_data_example.xlsx?raw=true" %>% 
  download.file(tmp) 
bad = tmp %>% read_xlsx()

# смотрим, что не так
bad %>% str()
bad %>% View()

library(naniar)
bad %<>% # выражение равносильно bad = bad %>%
  mutate(Weight = str_replace(Weight, ",", ".")) %>% # исправляем ошибку: заменяем , на .
  rename(Gender=`Пол`, Num_ticks=`Num ticks`) %>% # переименовываем переменные, чтобы дальше было удобнее
  mutate(Weight = as.numeric(Weight)) %>% # теперь изменяем тип переменной на числовой
  replace_with_na_all(~ str_detect(.x, regex("(^na$)|(.*hz.*)|(.*\\?.*)", ignore_case = T))) %>% # заменяем на NA (см. дальше)
  mutate(Gender = str_to_upper(Gender)) %>% # для унификации заменяем все буквы на большие
  mutate_at(c("Species", "Gender"), as.factor) # делаем факторами категориальные переменные

bad %>% View()
```

Здесь стоит отдельно остановиться на выражении `regex("(^na$)|(.*hz.*)|(.*\\?.*)", ignore_case = T)`. Речь идет об использовании регулярных выражений. Это способ указывать критерий для поиска или замен в строках. Простейший житейский пример регулярного выражения (правда, синтаксис там не очень правильный, зато понятный) - это когда мы выбираем файлы Excel выражением `*.xls(x)`. Здесь я не буду на них подробнее останавливаться, Вы можете подробнее прочитать про это по ссылкам далее [[1](https://stringr.tidyverse.org/articles/regular-expressions.html), [2](https://github.com/rstudio/cheatsheets/blob/master/regex.pdf), [3](https://cran.r-project.org/web/packages/naniar/vignettes/replace-with-na.html)].

## Анализируем новые данные

```r
# рандомизация порядка измерения проб:
# sample(c(rep('+', 20), rep('-',20))) %>% data.frame()

tmp = tempfile()
"https://github.com/lapotok/biochem_statistics/blob/master/2018/lesson3/bact_cells.xlsx?raw=true" %>% 
  download.file(tmp) 
bact = tmp %>% read_xlsx()
bact %>% View()

bact %<>% mutate(n_cells = (OD600_2-OD600_1)*8*10^8, n_cell_divisions = log2(OD600_2/OD600_1))
bact %>% ggqqplot("n_cells", facet.by = "IPTG")
bact %>% ggqqplot("n_cell_divisions", facet.by = "IPTG")
bact %>% 
  ggboxplot("IPTG", "n_cells", col="IPTG", add="jitter", add.params = list(size=3, alpha=.5), outlier.shape=NA) +
    stat_compare_means(method="t.test", label.x.npc = "left") +
    stat_compare_means(method="wilcox", label.x.npc = "right")
```

# Краткий справочник

## Пайплайны

* Операторы для пайплайнов
  - `%>%` для направления данных справа налево, от вывода одной функции на ввод другой (вместо вложенных функций); при этом данные передаются функции (которая справа) первым аргументом, а если хочется чтобы они передавались в другой аргумент, то для этого надо использовать `.`, как заменитель данных (примеры: `iris %>% nrow()` равнозначно `nrow(iris)`, а `iris %>% ggboxplot("Species", "Petal.Length", data=.)` равнозначно `ggboxplot("Species", "Petal.Length", data=iris)`)
  - `%$%` для экстрагирования из таблиц колонок или списков элементов списка, например `iris %$% leveneTest(Petal.Length, Species)` (вместо `leveneTest(iris$Petal.Length, iris$Species)`); при этом следующей функции никаких аргументов не передается, предполагается, что мы сами куда надо что надо укажем
  - `%<>%` для укороченной записи действия `A = A %>% ...` (будет записано как `A %<>% ...`)
  - `.` для указания на передаваемый через 
* Функции для использования в пайплайнах
  - `slice()` для выбора строк таблицы по номерам, например `iris %>% slice(c(1,3,4))`
  - `filter()` для выбора строк таблицы по критерию, например `iris %>% filter(Species == 'setosa' & Petal.Length > 1.6)`
  - `pluck()` для работы с определенной колоной таблицы (также см. `pull()`) или определенным элементом списка, например, `iris %>% pluck('Species') %>% unique()`
  - `select()` для выбора несколькиx колонок в таблице, например, `iris %>% select(Species, Petal.Length))`
  - ``` `[`()``` для выбора одновременно и строк и столбцов (как в классическом синтаксисе, там тоже используется ), например ```iris %>% `[`(1:10,1:2)``` или `iris %>% .[1:10,1:2]`
  - `na.omit()` для удаления из таблицы строк с пропущенными данными, например `airquality %>% na.omit()`
  - `replace_with_na_at()`(библиотека `naniar`) для замены на `NA` заданных значений из заданных колонок
  - `mutate()` для изменения старых или создания новых колонок, например `iris %>% mutate(scaled_pl = scale(Petal.Length)) %>% ggqqplot("scaled_pl", facet.by = "Species", ylab = "Scaled petal length")`
  - `gather()` для перевода таблицы из "широкого" формата в "длинный", например `iris %>% gather("var", "val", -Species)`
  - `spread()` для перевода таблицы из "длинного" формата в "широкий"
  - `summarise_at` для расчета выбранных статистик по выбранным колонкам, например, `iris %>% summarise_at(vars(Petal.Length, Sepal.Width), funs(overall.mean = mean, overall.sd = sd))`
  - `group_by()` + `ungroup()` - для создания групп с целью расчета внутригрупповых статистик или изменений (см. далее примеры)
  
**Пример 1**  на создание групп: среднее и стандартное отклонение для каждой из групп
    
```r
iris %>% 
 group_by(Species) %>% 
 summarise_at(vars(Petal.Length, Sepal.Width), funs(group.mean = mean, group.sd = sd))`
```
 **Пример 2** на создание групп: внутри каждой группы делаем z-трансформацию переменной, т.е. <img src="https://latex.codecogs.com/gif.latex?\fn_cm&space;\frac{x_i-mean(x)}{sd(x)}" title="\frac{x_i-mean(x)}{sd(x)}" />
    
```r
iris %>% 
 group_by(Species) %>% 
 mutate(scaled_pl = scale(Petal.Length)) %>% 
 ggqqplot("scaled_pl", facet.by = "Species", ylab = "Scaled within groups petal length")`
``` 

 **Замечание.** Если группировка данных больше не нужна, то лучше ее отменить после использования. Например,

```r
my_new_iris_table = iris %>% 
  group_by(Species) %>% 
  mutate(Petal.Length.GroupwiseScaled = scale(Petal.Length)) %>%
  ungroup()
```

# Примеры преобразования данных

В `R` разные функции принимают данные в разном формате. Где-то это векторы, где-то таблицы, где-то нужно привести два вектора (или две колонки), а где-то -- вектор значений и вектор группирующей переменной. Здесь мы разберем основные варианты.

Наиболее правильный формат хранения данных - таблица, где строки - наблюдения, а столбцы - переменные. Причем один столбец содержит 1 значение (например, "пол": "М" или "Ж"), а не несколько (например, "пол+возраст": "М 32", "Ж 21" ...). Из такого формата (он называется "широкий") мы будем преобразовывать данные для их анализа разными функциями.

## Формат `function(x, g)`

Пример - тест Ливена на гомогенность дисперсии в разных группах (чтобы понять, можно ли использовать Т-тест). Нужно в качестве аргументов указать вектор со значениями переменной (например, длина лепестка) и вектор со значениями группирующей переменной (например, вид ириса). Для этого надо "вытащить" отдельные колонки из таблицы `iris` оператором `%$%`.

```r
library(car)
iris %$%
 leveneTest(Petal.Length, Species)
```
## Формат `function(x,  y, data = d)`

Почти идентично предыдущему случаю. Но некоторые функции требуют, чтобы данные представляли в виде таблицы. Т.е. мы не разбиваем таблицу на колонки, а передаем ее следующей функции в явном (.) или неявном виде (пропущенным первым аргументом) с помощью оператора `%>%`.

```r
iris %>% 
 ggplot(aes(Species, Petal.Length)) +
 geom_boxplot()

# если надо указать на таблицу в явном виде, на нее можно сослаться с помощью .
iris %>% 
 ggplot(aes(Species, Petal.Length), data = .) +
 geom_boxplot()
```

## Формат `function(x ~ g)`

Пример - Т-тест, в случае если требуется сравнить значения одной переменной в двух группах данных, причем сравниваемые значения находятся в одной колонке, а другая содержит принадлежность к той или иной группе данных. В данном примере у нас групп больше, чем 2, поэтому сначала нам надо выбрать две группы, которые будем сравнивать.

```r
iris %>% 
 filter(Species %in% c('setosa', 'versicolor')) %$% # Т-тестом мы можем сравнивать только 2 группы!
 t.test(Petal.Length ~ Species)

# можно использовать формулу x ~ g и ссылаясь на переменные таблицы, но указав на таблицу с помощью .
iris %>% 
 filter(Species %in% c('setosa', 'versicolor')) %>% # Т-тестом мы можем сравнивать только 2 группы!
 t.test(Petal.Length ~ Species, data=.)
```

## Формат `function(x1, x2)`

Пример - для сравнения двух групп в непараметрическом тесте Колмогорова-Смирнова для сравнения средних (`ks.test()`). Эта функция требует на вход два вектора, которые соответствующие значениям каждой из групп. А у нас данные организованы иначе - сравниваемые значения находятся в одной колонке, а другая содержит принадлежность к той или иной группе данных.

Итак, мы должны сделать следующее

* выбрать две группы, которые будем сравнивать
* разбить на две переменные значения признака, относящиеся к разным группам
  - вытащить колонку со значениями признака и колонку с групповой принадлежностью
  - разбить с помощью функции `split()` значения признака на группы
  - задать полученные группы в качестве аргументов функции `ks.test()`

```r
iris %>% 
  filter(Species %in% c('setosa', 'versicolor')) %$% # выбираем группы и достаем отдельные колонки таблицы
  split(Petal.Length, Species) %$% # разбиваем значения на группы и достаем значения из каждой группы
  ks.test(setosa, versicolor)
```


## Формат `function(x1, x2, data = d)`

Почти идентично предыдущему случаю. Но некоторые функции требуют, чтобы данные представляли в виде таблицы.

```r
iris %>% 
  filter(Species %in% c('setosa', 'versicolor')) %>% # выбираем группы
  droplevels() %$% # удаляем из фактора Species ненужные уровни (вид virginica, которого нет уже), достаем отдельные колонки таблицы
  split(Petal.Length, Species) %>% # разбиваем значения на группы
  as.data.frame() %>% # преобразуем полученный список в таблицу данных
  ggscatter("setosa", "versicolor") # передаем через пайплайн таблицу на функцию ggscatter первым аргументом (можно было бы и не первым аргументом, используя ".")
```


# Идеи

* Упражнения на функции пайплайнов
* Упражнения на операторы пайплайнов
* Упражнения на фильтрацию и преобразования колонок (общие и по группам)
* Тестовые данные: выбрать тест, построить боксплот
* Собрать график по кускам
* замена значений на NA 
* обработка ошибок (str_replace)
