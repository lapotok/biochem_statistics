# Полезные дополнения

Для работы с пайплайнами и графиками загрузите следующие библиотеки

 ```r
library(tidyverse)
library(ggpubr)
library(magrittr)
library(readxl)
library(car)
```

## Пайплайны

* Операторы для пайплайнов
  - `%>%` для направления данных справа налево, от вывода одной функции на ввод другой (вместо вложенных функций); при этом данные передаются функции (которая справа) первым аргументом, а если хочется чтобы они передавались в другой аргумент, то для этого надо использовать `.`, как заменитель данных (примеры: `iris %>% nrow()` равнозначно `nrow(iris)`, а `iris %>% ggboxplot("Species", "Petal.Length", data=.)` равнозначно `ggboxplot("Species", "Petal.Length", data=iris)`)
  - `%$%` для экстрагирования из таблиц колонок или списков элементов списка, например `iris %$% leveneTest(Petal.Length, Species)` (вместо `leveneTest(iris$Petal.Length, iris$Species)`); при этом следующей функции никаких аргументов не передается, предполагается, что мы сами куда надо что надо укажем
  - `%<>%` для укороченной записи действия `A = A %>% ...` (будет записано как `A %<>% ...`)
  - `.` для указания на передаваемый через 
* Функции для использования в пайплайнах
  - `slice()` для выбора строк таблицы по номерам, например `iris %>% slice(c(1,3,4))`
  - `filter()` для выбора строк таблицы по критерию, например `iris %>% filter(Species == 'setosa' & Petal.Length > 1.6)`
  - `pluck()` для работы с определенной колоной таблицы (также см. `pull()`) или определенным элементом списка, например, `iris %>% pluck('Species') %>% unique()`
  - `select()` для выбора несколькиx колонок в таблице, например, `iris %>% select(Species, Petal.Length))`
  - ``` `[`()``` для выбора одновременно и строк и столбцов (как в классическом синтаксисе, там тоже используется ), например ```iris %>% `[`(1:10,1:2)``` или `iris %>% .[1:10,1:2]`
  - `na.omit()` для удаления из таблицы строк с пропущенными данными, например `airquality %>% na.omit()`
  - `replace_with_na_at()`(библиотека `naniar`) для замены на `NA` заданных значений из заданных колонок
  - `mutate()` для изменения старых или создания новых колонок, например `iris %>% mutate(scaled_pl = scale(Petal.Length)) %>% ggqqplot("scaled_pl", facet.by = "Species", ylab = "Scaled petal length")`
  - `gather()` для перевода таблицы из "широкого" формата в "длинный", например `iris %>% gather("var", "val", -Species)`
  - `spread()` для перевода таблицы из "длинного" формата в "широкий"
  - `summarise_at` для расчета выбранных статистик по выбранным колонкам, например, `iris %>% summarise_at(vars(Petal.Length, Sepal.Width), funs(overall.mean = mean, overall.sd = sd))`
  - `group_by()` + `ungroup()` - для создания групп с целью расчета внутригрупповых статистик или изменений (см. далее примеры)
  
**Пример 1**  на создание групп: среднее и стандартное отклонение для каждой из групп
    
```r
iris %>% 
 group_by(Species) %>% 
 summarise_at(vars(Petal.Length, Sepal.Width), funs(group.mean = mean, group.sd = sd))`
```
 **Пример 2** на создание групп: внутри каждой группы делаем z-трансформацию переменной, т.е. <img src="https://latex.codecogs.com/gif.latex?\fn_cm&space;\frac{x_i-mean(x)}{sd(x)}" title="\frac{x_i-mean(x)}{sd(x)}" />
    
```r
iris %>% 
 group_by(Species) %>% 
 mutate(scaled_pl = scale(Petal.Length)) %>% 
 ggqqplot("scaled_pl", facet.by = "Species", ylab = "Scaled within groups petal length")`
``` 

 **Замечание.** Если группировка данных больше не нужна, то лучше ее отменить после использования. Например,

```r
my_new_iris_table = iris %>% 
  group_by(Species) %>% 
  mutate(Petal.Length.GroupwiseScaled = scale(Petal.Length)) %>%
  ungroup()
```

# Примеры преобразования данных

В `R` разные функции принимают данные в разном формате. Где-то это векторы, где-то таблицы, где-то нужно привести два вектора (или две колонки), а где-то -- вектор значений и вектор группирующей переменной. Здесь мы разберем основные варианты.

Наиболее правильный формат хранения данных - таблица, где строки - наблюдения, а столбцы - переменные. Причем один столбец содержит 1 значение (например, "пол": "М" или "Ж"), а не несколько (например, "пол+возраст": "М 32", "Ж 21" ...). Из такого формата (он называется "широкий") мы будем преобразовывать данные для их анализа разными функциями.

## Формат `function(x, g)`

Пример - тест Ливена на гомогенность дисперсии в разных группах (чтобы понять, можно ли использовать Т-тест). Нужно в качестве аргументов указать вектор со значениями переменной (например, длина лепестка) и вектор со значениями группирующей переменной (например, вид ириса). Для этого надо "вытащить" отдельные колонки из таблицы `iris`.

```r
library(car)
iris %$%
 leveneTest(Petal.Length, Species)
```

## Формат `function(x ~ g)`

Пример - Т-тест, в случае если требуется сравнить значения одной переменной в двух группах данных, причем сравниваемые значения находятся в одной колонке, а другая содержит принадлежность к той или иной группе данных. В данном примере у нас групп больше, чем 2, поэтому сначала нам надо выбрать две группы, которые будем сравнивать.

```r
iris %>% 
 filter(Species %in% c('setosa', 'versicolor')) %$% # Т-тестом мы можем сравнивать только 2 группы!
 t.test(Petal.Length ~ Species)
```

## Формат `function(x ~ g, data = d)`

Почти идентично предыдущему случаю. Но некоторые функции требуют, чтобы данные представляли в виде таблицы.

```r
iris %>% 
 filter(Species %in% c('setosa', 'versicolor')) %>% # Т-тестом мы можем сравнивать только 2 группы!
 t.test(Petal.Length ~ Species, data=.)
```

## Формат `function(x1, x2)`

Пример - для сравнения двух групп в непараметрическом тесте Колмогорова-Смирнова для сравнения средних (`ks.test()`). Эта функция требует на вход два вектора, которые соответствующие значениям каждой из групп. А у нас данные организованы иначе - сравниваемые значения находятся в одной колонке, а другая содержит принадлежность к той или иной группе данных.

Итак, мы должны сделать следующее

* выбрать две группы, которые будем сравнивать
* разбить на две переменные значения признака, относящиеся к разным группам
  - вытащить колонку со значениями признака и колонку с групповой принадлежностью
  - разбить с помощью функции `split()` значения признака на группы
  - задать полученные группы в качестве аргументов функции `ks.test()`

```r
iris %>% 
  filter(Species %in% c('setosa', 'versicolor')) %$% # выбираем группы и достаем отдельные колонки таблицы
  split(Petal.Length, Species) %$% # разбиваем значения на группы и достаем значения из каждой группы
  ks.test(setosa, versicolor)
```


## Формат `function(x1, x2, data = d)`

Почти идентично предыдущему случаю. Но некоторые функции требуют, чтобы данные представляли в виде таблицы.

```r
iris %>% 
  filter(Species %in% c('setosa', 'versicolor')) %>% # выбираем группы
  droplevels() %$% # удаляем из фактора Species ненужные уровни (вид virginica, которого нет уже), достаем отдельные колонки таблицы
  split(Petal.Length, Species) %>% # разбиваем значения на группы
  as.data.frame() %>% # преобразуем полученный список в таблицу данных
  ggscatter("setosa", "versicolor") # передаем через пайплайн таблицу на функцию ggscatter первым аргументом (можно было бы и не первым аргументом, используя ".")
```


# Идеи

* Упражнения на функции пайплайнов
* Упражнения на операторы пайплайнов
* Упражнения на фильтрацию и преобразования колонок (общие и по группам)
* Тестовые данные: выбрать тест, построить боксплот
* Собрать график по кускам
