# Задание

Для работы с пайплайнами и графиками загрузите следующие библиотеки

 ```r
library(tidyverse)
library(ggpubr)
library(magrittr)
library(readxl)
library(car)
```

Ссылки на различные полезные ресурсы я помещаю [здесь](https://github.com/lapotok/biochem_statistics/tree/master/2018), если вдруг Вам недостаточно материалов, которые я давал на лекции или Гугл к Вам недружелюбен.

Для того чтобы сделать это задание Вам будет полезно вспомнить, что мы делали на уроке, а так же заглянуть в краткий справочник, который я прилагаю [ниже](#%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%B8%D0%B9-%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA) на этой странице.

## Анализируем новые данные

Файл с данными, с которыми Вам предстоит работать, находится [здесь](https://github.com/lapotok/biochem_statistics/blob/master/2018/lesson3/bact_cells_bad.xlsx?raw=true). Вы можете скачать его на компьютер и далее с ним работать, либо его можно с помощью `R` скачать в какую-то директорию или во временный файл, а затем открыть командой `read_excel()`.

```r
tmp = tempfile()
"https://github.com/lapotok/biochem_statistics/blob/master/2018/lesson3/bact_cells_bad.xlsx?raw=true" %>% 
  download.file(tmp) 
bact = tmp %>% read_excel()
```
Экспримент состоял в следующем. Были взяты клетки _E. coli_ Rosetta2(DE3)pLysS с плазмидой pET22b+/hfsTnI и половина из них на OD600=0.615 индуцирована 0.4 mM IPTG. Далее было измерено OD600 через 25 мин после индукции в клетках с IPTG и без. Надо сравнить рост клеток в этих пробах (по 20 аликвот каждого типа). Оптические плотности измерялись не подряд, а в случайном порядке, чтобы исключить влияние "глюков" приборов и подроста клеток в время измерения на результат. Последовательность случайных измерений создавалась командой

```r
sample(c(rep('+', 20), rep('-',20))) %>% data.frame()
```

Вам необходимо открыть файл, проверить на предмет ошибок, исправить их (см. пример во второй части этой страницы). Затем надо проанализировать различия в росте между неиндуцированными и индуцированными клетками.

```r
# смотрим на файл
bact %>% str()
bact %>% View()

# правим, что не так:
bact %<>% 
 rename(IPTG = ..., OD600_1 = ...) %>% 
 mutate(OD600_2 = str_replace(...)) %>% 
 mutate... # сделать столбец OD600_2 числовым типом

# смотрим на данные, нет ли опечаток
bact %>% ggboxplot(...)

# исправляем их в Excel и повторно открываем документ, или здесь
bact[31, "OD600_2"] = ...

# расчитываем из разницы OD количество образовавшихся клеток (OD600 = 1 соответствует 8*10^8 клеток)
bact %<>% mutate(n_new_cells = ...)
bact %>% ggqqplot("n_new_cells", facet.by = ...)
bact %>% 
  ggboxplot(...) + # надо окрасить данные согласно видам, добавить точки данных, подписать график и оси, посмотрите, что еще можно отобразить
    stat_compare_means(...) # подписать значение t-test или wilcoxon test p.value

# проверить нормальность данных

# проверить гомогенность дисперсий

# сравнить средние

# учимся создавать графики по частям с использованием библиотеки ggplot

library(ggforce)
bact %>% ggplot(aes(...)) + # задаем x, y и переменную, задающую окрашивание (индукцировано или нет)
  geom_boxplot(...) + # хотелось бы убрать outliers в виде точек, т.к. далее мы хотим рисовать точки
  geom_sina(...) + # хотелось бы укрупнить точки и сделать их полупрозрачными
  stat_summary(geom="errorbar", ...) + # рисуем среднее +/- sd (разброс)
  stat_summary(geom="point", ...) + # рисуем среднее (точка)
  # и то же самое для среднее с доверительными интервалами
  theme_classic()

# кстати, графики можно сохранять в PowerPoint/Word и потом там редактировать, как объекты MS Office!
my_plot = bact %>% ggplot(...) ...

library(rvg)
library(officer)
doc <- read_pptx() %>% # создаем презентацию
  add_slide(layout = "Title and Content", master = "Office Theme") %>% # добавляем слайд 1
  ph_with_vg(code = print(my_plot), type = "body") %>% # вставляем график
  add_slide(layout = "Title and Content", master = "Office Theme") %>% # добавляем слайд 2 (если надо, можно сколько угодно)
  ph_with_vg(code = print(my_plot), type = "body", height = 4.06, width = 5.39) %>% # можно изменить размер графика
  print(target = "demo.pptx") # задаем имя файла
```

Про сохранение графиков, созданных в `R` для использования в MS Office подробнее написано в данных ссылках [[1](https://davidgohel.github.io/officer/articles/powerpoint.html), [2](https://blog.revolutionanalytics.com/2017/10/office-charts.html)].

Написанный Вами код нужно отправить в [форму](https://docs.google.com/forms/d/e/1FAIpQLSeUJNnlx7Bh6DYJhRDLnyuh7_6sDYv-FRvO6pQ4p7ZsQfaTxg/viewform?usp=sf_link).

# Краткий справочник

## Читаем файл и исправляем ошибки

Учимся исправлять ошибки, которые мы уже научились находить. Какие-то из них можно исправить уже на этапе подготовки данных (см. [рекомендации](http://www.sthda.com/english/wiki/best-practices-in-preparing-data-files-for-importing-into-r)).

* неправильный десятичный разделитель
* неправильно определенный тип колонки Weight (текст, вместо чисел)
* пропущенные данные, абы как названные (надо составить указания для `R` в формате регулярных выражений, что заменять на NA)
* русскоязычные названия переменных и названия с пробелами, что может вызывать неудобство в работе, например необходимость их закавычивать при обращении к ним (```bad$`Num ticks` ```)
* неправильно определенный тип колонки Weight (текст, вместо чисел)
* в колонке "Пол" буквы разного регистра обозначают одно и то же

```r
# так можно скачивать файлы из интернета во временный файл, чтобы потом открывать
tmp = tempfile() # генерируем название временного файла
"https://github.com/lapotok/biochem_statistics/blob/master/2018/lesson1/bad_data_example.xlsx?raw=true" %>% 
  download.file(tmp) 
bad = tmp %>% read_xlsx()

# смотрим, что не так
bad %>% str()
bad %>% View()

library(naniar)
bad %<>% # выражение равносильно bad = bad %>%
  mutate(Weight = str_replace(Weight, ",", ".")) %>% # исправляем ошибку: заменяем , на .
  rename(Gender=`Пол`, Num_ticks=`Num ticks`) %>% # переименовываем переменные, чтобы дальше было удобнее
  mutate(Weight = as.numeric(Weight)) %>% # теперь изменяем тип переменной на числовой
  replace_with_na_all(~ str_detect(.x, regex("(^na$)|(.*hz.*)|(.*\\?.*)", ignore_case = T))) %>% # заменяем на NA (см. дальше)
  mutate(Gender = str_to_upper(Gender)) %>% # для унификации заменяем все буквы на большие
  mutate_at(c("Species", "Gender"), as.factor) # делаем факторами категориальные переменные

bad %>% View()
```

Здесь стоит отдельно остановиться на выражении `regex("(^na$)|(.*hz.*)|(.*\\?.*)", ignore_case = T)`. Речь идет об использовании регулярных выражений. Это способ указывать критерий для поиска или замен в строках. Простейший житейский пример регулярного выражения (правда, синтаксис там не очень правильный, зато понятный) - это когда мы выбираем файлы Excel выражением `*.xls(x)`. Здесь я не буду на них подробнее останавливаться, Вы можете подробнее прочитать про это по ссылкам далее [[1](https://stringr.tidyverse.org/articles/regular-expressions.html), [2](https://github.com/rstudio/cheatsheets/blob/master/regex.pdf), [3](https://cran.r-project.org/web/packages/naniar/vignettes/replace-with-na.html)].

## Пайплайны

* Операторы для пайплайнов
  - `%>%` для направления данных справа налево, от вывода одной функции на ввод другой (вместо вложенных функций); при этом данные передаются функции (которая справа) первым аргументом, а если хочется чтобы они передавались в другой аргумент, то для этого надо использовать `.`, как заменитель данных (примеры: `iris %>% nrow()` равнозначно `nrow(iris)`, а `iris %>% ggboxplot("Species", "Petal.Length", data=.)` равнозначно `ggboxplot("Species", "Petal.Length", data=iris)`)
  - `%$%` для экстрагирования из таблиц колонок или списков элементов списка, например `iris %$% leveneTest(Petal.Length, Species)` (вместо `leveneTest(iris$Petal.Length, iris$Species)`); при этом следующей функции никаких аргументов не передается, предполагается, что мы сами куда надо что надо укажем
  - `%<>%` для укороченной записи действия `A = A %>% ...` (будет записано как `A %<>% ...`)
  - `.` для указания на передаваемый через пайплайн объект
* Функции для использования в пайплайнах
  - `slice()` для выбора строк таблицы по номерам, например `iris %>% slice(c(1,3,4))`
  - `filter()` для выбора строк таблицы по критерию, например `iris %>% filter(Species == 'setosa' & Petal.Length > 1.6)`
  - `pluck()` для работы с определенной колоной таблицы (также см. `pull()`) или определенным элементом списка, например, `iris %>% pluck('Species') %>% unique()`
  - `select()` для выбора несколькиx колонок в таблице, например, `iris %>% select(Species, Petal.Length))`
  - ``` `[`()``` для выбора одновременно и строк и столбцов (как в классическом синтаксисе, там тоже используется ), например ```iris %>% `[`(1:10,1:2)``` или `iris %>% .[1:10,1:2]`
  - `na.omit()` для удаления из таблицы строк с пропущенными данными, например `airquality %>% na.omit()`
  - `replace_with_na_at()`(библиотека `naniar`) для замены на `NA` заданных значений из заданных колонок
  - `mutate()` для изменения старых или создания новых колонок, например `iris %>% mutate(scaled_pl = scale(Petal.Length)) %>% ggqqplot("scaled_pl", facet.by = "Species", ylab = "Scaled petal length")`
  - `gather()` для перевода таблицы из "широкого" формата в "длинный", например `iris %>% gather("var", "val", -Species)`
  - `spread()` для перевода таблицы из "длинного" формата в "широкий"
  - `summarise_at` для расчета выбранных статистик по выбранным колонкам, например, `iris %>% summarise_at(vars(Petal.Length, Sepal.Width), funs(overall.mean = mean, overall.sd = sd))`
  - `group_by()` + `ungroup()` - для создания групп с целью расчета внутригрупповых статистик или изменений (см. далее примеры)
  
**Пример 1**  на создание групп: среднее и стандартное отклонение для каждой из групп
    
```r
iris %>% 
 group_by(Species) %>% 
 summarise_at(vars(Petal.Length, Sepal.Width), funs(group.mean = mean, group.sd = sd))`
 
# при желании можно определить свою функцию, которая возвращает какое-то значение и использовать ее тоже
CV = function(x) sd(x)/mean(x)*100
iris %>% 
 group_by(Species) %>% 
 summarise_at(vars(Petal.Length, Sepal.Width), funs(group.mean = mean, group.sd = sd, group.CV = CV))`
```
 **Пример 2** на создание групп: внутри каждой группы делаем z-трансформацию переменной, т.е. <img src="https://latex.codecogs.com/gif.latex?\fn_cm&space;\frac{x_i-mean(x)}{sd(x)}" title="\frac{x_i-mean(x)}{sd(x)}" />
    
```r
iris %>% 
 group_by(Species) %>% 
 mutate(scaled_pl = scale(Petal.Length)) %>% 
 ggqqplot("scaled_pl", facet.by = "Species", ylab = "Scaled within groups petal length")`
``` 

 **Замечание.** Если группировка данных больше не нужна, то лучше ее отменить после использования. Например,

```r
my_new_iris_table = iris %>% 
  group_by(Species) %>% 
  mutate(Petal.Length.GroupwiseScaled = scale(Petal.Length)) %>%
  ungroup()
```

## Примеры преобразования данных

В `R` разные функции принимают данные в разном формате. Где-то это векторы, где-то таблицы, где-то нужно привести два вектора (или две колонки), а где-то -- вектор значений и вектор группирующей переменной. Здесь мы разберем основные варианты.

Наиболее правильный формат хранения данных - таблица, где строки - наблюдения, а столбцы - переменные. Причем один столбец содержит 1 значение (например, "пол": "М" или "Ж"), а не несколько (например, "пол+возраст": "М 32", "Ж 21" ...). Из такого формата (он называется "широкий") мы будем преобразовывать данные для их анализа разными функциями.

### Формат `function(x, g)`

Пример - тест Ливена на гомогенность дисперсии в разных группах (чтобы понять, можно ли использовать Т-тест). Нужно в качестве аргументов указать вектор со значениями переменной (например, длина лепестка) и вектор со значениями группирующей переменной (например, вид ириса). Для этого надо "вытащить" отдельные колонки из таблицы `iris` оператором `%$%`.

```r
library(car)
iris %$%
 leveneTest(Petal.Length, Species)
```
### Формат `function(x,  y, data = d)`

Почти идентично предыдущему случаю. Но некоторые функции требуют, чтобы данные представляли в виде таблицы. Т.е. мы не разбиваем таблицу на колонки, а передаем ее следующей функции в явном (.) или неявном виде (пропущенным первым аргументом) с помощью оператора `%>%`.

```r
iris %>% 
 ggplot(aes(Species, Petal.Length)) +
 geom_boxplot()

# если надо указать на таблицу в явном виде, на нее можно сослаться с помощью .
iris %>% 
 ggplot(aes(Species, Petal.Length), data = .) +
 geom_boxplot()
```

### Формат `function(x ~ g)`

Пример - Т-тест, в случае если требуется сравнить значения одной переменной в двух группах данных, причем сравниваемые значения находятся в одной колонке, а другая содержит принадлежность к той или иной группе данных. В данном примере у нас групп больше, чем 2, поэтому сначала нам надо выбрать две группы, которые будем сравнивать.

```r
iris %>% 
 filter(Species %in% c('setosa', 'versicolor')) %$% # Т-тестом мы можем сравнивать только 2 группы!
 t.test(Petal.Length ~ Species)

# можно использовать формулу x ~ g и ссылаясь на переменные таблицы, но указав на таблицу с помощью .
iris %>% 
 filter(Species %in% c('setosa', 'versicolor')) %>% # Т-тестом мы можем сравнивать только 2 группы!
 t.test(Petal.Length ~ Species, data=.)
```

### Формат `function(x1, x2)`

Пример - для сравнения двух групп в непараметрическом тесте Колмогорова-Смирнова для сравнения средних (`ks.test()`). Эта функция требует на вход два вектора, которые соответствующие значениям каждой из групп. А у нас данные организованы иначе - сравниваемые значения находятся в одной колонке, а другая содержит принадлежность к той или иной группе данных.

Итак, мы должны сделать следующее

* выбрать две группы, которые будем сравнивать
* разбить на две переменные значения признака, относящиеся к разным группам
  - вытащить колонку со значениями признака и колонку с групповой принадлежностью
  - разбить с помощью функции `split()` значения признака на группы
  - задать полученные группы в качестве аргументов функции `ks.test()`

```r
iris %>% 
  filter(Species %in% c('setosa', 'versicolor')) %$% # выбираем группы и достаем отдельные колонки таблицы
  split(Petal.Length, Species) %$% # разбиваем значения на группы и достаем значения из каждой группы
  ks.test(setosa, versicolor)
```


### Формат `function(x1, x2, data = d)`

Почти идентично предыдущему случаю. Но некоторые функции требуют, чтобы данные представляли в виде таблицы.

```r
iris %>% 
  filter(Species %in% c('setosa', 'versicolor')) %>% # выбираем группы
  droplevels() %$% # удаляем из фактора Species ненужные уровни (вид virginica, которого нет уже), достаем отдельные колонки таблицы
  split(Petal.Length, Species) %>% # разбиваем значения на группы
  as.data.frame() %>% # преобразуем полученный список в таблицу данных
  ggscatter("setosa", "versicolor") # передаем через пайплайн таблицу на функцию ggscatter первым аргументом (можно было бы и не первым аргументом, используя ".")
```
